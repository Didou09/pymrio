

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Reference &mdash; pymrio 1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pymrio 1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pymrio 1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-pymrio">
<span id="api-reference"></span><h1>API Reference<a class="headerlink" href="#module-pymrio" title="Permalink to this headline">¶</a></h1>
<div class="section" id="function-and-classes-for-symmetric-mrio-systems">
<h2>Function and classes for (symmetric) MRIO systems<a class="headerlink" href="#function-and-classes-for-symmetric-mrio-systems" title="Permalink to this headline">¶</a></h2>
<p>The classes and tools in this module should work with any symetric IO system.</p>
<p>The main class of the module (IOSystem) has attributes .A, .L, ... 
corresponding to a standard IO classification. 
Data can e assigned directly to the attributes or, in case of EXIOBASE 2.0, 
also by calling &#8216;convert_exiobase20&#8217; and loading the converted
txt files.</p>
<div class="section" id="data-storage">
<h3>Data storage<a class="headerlink" href="#data-storage" title="Permalink to this headline">¶</a></h3>
<p>Txt files together with a ini file are used for storing data. In addition, 
the IOSystem with all data can also be pickled (binary). 
Conversion to hdf5 and mat should be implemented...</p>
</div>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">core.EXIOError:</th><td class="field-body">Base class for errors concerning EXIOBASE download and 
structure.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">core.IO_CALCError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Base class for errors occuring during the calculation 
of the IO System</td>
</tr>
<tr class="field-odd field"><th class="field-name">IOSystem:</th><td class="field-body">Main class for accessing and calculating the IO system</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">convert_exiobase20():</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Converts exiobase 2.0 download (CREEA) 
with transactions to separate data/header files.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">build_agg_vec():</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Builds an combined aggregation vector based 
on various classifications</td>
</tr>
<tr class="field-odd field"><th class="field-name">load_pickle():</th><td class="field-body">Reads the data for the IOSystem from a pickle file</td>
</tr>
<tr class="field-even field"><th class="field-name">load_test():</th><td class="field-body">Reads the small test mrio from ./test_mrio</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="misc">
<h3>Misc<a class="headerlink" href="#misc" title="Permalink to this headline">¶</a></h3>
<p>Standard abbreviation for that module: mr
Dependencies:</p>
<ul>
<li><p class="first">numpy</p>
</li>
<li><p class="first">scipy</p>
</li>
<li><p class="first">pandas</p>
</li>
<li><p class="first">matplotlib</p>
</li>
<li><dl class="first docutils">
<dt>docutils (only for IOSystem.report* if format is html and tex - not </dt>
<dd><p class="first last">imported otherwise)</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="open-points">
<h3>Open points<a class="headerlink" href="#open-points" title="Permalink to this headline">¶</a></h3>
<p>Must save index_col and header in ini</p>
<ul class="simple">
<li>export functions (xls, hdf5, mat, exiobase)</li>
<li>multiplier report</li>
<li>parser for other MRIO (1. exiobase, 2. wiod)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Konstantin Stadler</td>
</tr>
<tr class="field-even field"><th class="field-name">license:</th><td class="field-body">BSD 2-Clause License</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pymrio.Extension">
<em class="property">class </em><tt class="descclassname">pymrio.</tt><tt class="descname">Extension</tt><big>(</big><em>name</em>, <em>F=None</em>, <em>FY=None</em>, <em>S=None</em>, <em>M=None</em>, <em>D_fp=None</em>, <em>D_terr=None</em>, <em>D_imp=None</em>, <em>D_exp=None</em>, <em>unit=None</em>, <em>iosystem=None</em>, <em>version=None</em>, <em>year=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymrio.Extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Class which gathers all information for one extension of the IOSystem</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>name</td>
<td>(string) Every extension must have a name. This can (reconmmended) be the name of the instance. However, for plotting and saving this can also be changed.  This name will also be used for saving the extension as prefix to the attributes.</td>
</tr>
<tr class="row-even"><td>F</td>
<td>(pandas.DataFrame) Total direct impacts with columns as Z. Index with ([&#8216;stressor&#8217;, &#8216;compartment&#8217;]). The second level &#8216;compartment&#8217; is optional</td>
</tr>
<tr class="row-odd"><td>FY</td>
<td>(pandas.DataFrame) Extension of final demand with columns a y and index as F</td>
</tr>
<tr class="row-even"><td>S</td>
<td>(pandas.DataFrame) Direct impact (extensions) coefficients with multiindex as F</td>
</tr>
<tr class="row-odd"><td>M</td>
<td>(pandas.DataFrame) Multipliers with multiindex as F</td>
</tr>
<tr class="row-even"><td>D_fp</td>
<td>(pandas.DataFrame) Footprint of consumption,  further specification with _reg (per region) or _cap (per capita) possible</td>
</tr>
<tr class="row-odd"><td>D_terr</td>
<td>(pandas.DataFrame) Territorial accounts, further specification with _reg (per region) or _cap (per capita) possible</td>
</tr>
<tr class="row-even"><td>D_imp</td>
<td>(pandas.DataFrame) Import accounts (amount of &#8216;extension&#8217; embodied in imports), further specification with _reg (per region) or _cap (per capita) possible</td>
</tr>
<tr class="row-odd"><td>D_exp</td>
<td>(pandas.DataFrame) Export accounts (amount of &#8216;extension&#8217; embodied in exports), further specification with _reg (per region) or _cap (per capita) possible</td>
</tr>
<tr class="row-even"><td>unit</td>
<td>(pandas.DataFrame) Unit for each row of the extension</td>
</tr>
<tr class="row-odd"><td>iosystem</td>
<td>(string) Note for the IOSystem, recommended to be &#8216;pxp&#8217; or &#8216;ixi&#8217; for product by product or industry by industry. However, this can be any string and can have more information if needed (eg for different technoloy assumptions) The string will be passed to the IOSystem</td>
</tr>
<tr class="row-even"><td>version</td>
<td>(string) This can be used as a version tracking system.</td>
</tr>
<tr class="row-odd"><td>year</td>
<td>(int) Baseyear of the extension data</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="pymrio.Extension.calc_system">
<tt class="descname">calc_system</tt><big>(</big><em>x</em>, <em>L</em>, <em>Y_agg</em>, <em>population=None</em><big>)</big><a class="headerlink" href="#pymrio.Extension.calc_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the missing part of the extension plus accounts</p>
<p>This method uses y aggregated across specified y categories</p>
<p>Calculates:</p>
<ul>
<li><dl class="first docutils">
<dt>for each sector and country: </dt>
<dd><p class="first last">D, M, D_fp, D_terr_sector, D_imp_sector, D_exp_sector</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>for each region:  </dt>
<dd><p class="first last">D_fp_reg, D_terr_reg, D_imp_reg, D_exp_reg,</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>for each region (if population vector is given): </dt>
<dd><p class="first last">D_fp_cap, D_terr_cap, D_imp_cap, D_exp_cap</p>
</dd>
</dl>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Industry output column vector</p>
</div></blockquote>
<p><strong>L</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Leontief input output table L</p>
</div></blockquote>
<p><strong>Y_agg</strong> : pandas.DataFrame or np.array</p>
<blockquote>
<div><p>The final demand aggregated (one category per country)</p>
</div></blockquote>
<p><strong>population</strong> : pandas.DataFrame or np.array, optional</p>
<blockquote class="last">
<div><p>Row vector with population per region</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Only attributes which are not None are recalculated (for D_* this is
checked for each group (reg, cap, and w/o appendix)).</p>
</dd></dl>

<dl class="method">
<dt id="pymrio.Extension.get_row_data">
<tt class="descname">get_row_data</tt><big>(</big><em>row</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#pymrio.Extension.get_row_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dict with all available data for a row in the extension</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>row</strong> : tuple, list, string</p>
<blockquote>
<div><p>A valid index for the extension DataFrames</p>
</div></blockquote>
<p><strong>name</strong> : string, optional</p>
<blockquote>
<div><p>If given, adds a key &#8216;name&#8217; with the given value to the dict. In
that case the dict can be 
used directly to build a new extension.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">dict object with the data (pandas DataFrame)for the specific rows</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.Extension.get_rows">
<tt class="descname">get_rows</tt><big>(</big><big>)</big><a class="headerlink" href="#pymrio.Extension.get_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the rows of the extension</p>
</dd></dl>

<dl class="method">
<dt id="pymrio.Extension.per_source">
<tt class="descname">per_source</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#pymrio.Extension.per_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a extension disaggregated into the regional source</p>
<p>The returned extension included F, FY if present in the original
extension, and units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Name</strong> : string (optional)</p>
<blockquote>
<div><p>The new name for the extension, 
if None (default): original name + &#8216;per source region&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">Extension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.Extension.plot_account">
<tt class="descname">plot_account</tt><big>(</big><em>row</em>, <em>per_capita=False</em>, <em>file_name=False</em>, <em>file_dpi=600</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymrio.Extension.plot_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots D_terr, D_fp, D_imp and D_exp for the specified row</p>
<p>Per default the accounts are plotted as bar charts. 
However, any valid keyword for the pandas.DataFrame.plot 
method can be passed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>row</strong> : string, tuple or int</p>
<blockquote>
<div><p>A valid index for the row in the extension which 
should be plotted (one(!) row - no list allowed)</p>
</div></blockquote>
<p><strong>per_capita</strong> : boolean, optional</p>
<blockquote>
<div><p>Plot the per capita accounts instead of the absolute values
default is false</p>
</div></blockquote>
<p><strong>file_name</strong> : path string, optional</p>
<blockquote>
<div><p>If given, saves the plot to the given filename</p>
</div></blockquote>
<p><strong>file_dpi</strong> : int, optional</p>
<blockquote>
<div><p>Dpi for saving the figure, default 600</p>
</div></blockquote>
<p><strong>**kwargs</strong> : key word arguments, optional</p>
<blockquote>
<div><p>This will be passed directly to the pd.DataFrame.plot method</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">Axis as given by pandas.DataFrame.plot, None in case of errors</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.Extension.report_accounts">
<tt class="descname">report_accounts</tt><big>(</big><em>path</em>, <em>per_region=True</em>, <em>per_capita=False</em>, <em>pic_size=1000</em>, <em>format='rst'</em>, <em>ffname=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymrio.Extension.report_accounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a report to the given path for the regional accounts</p>
<p>The report consists of a text file and a folder with the pics 
(both names following parameter name)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote>
<div><p>Root path for the report</p>
</div></blockquote>
<p><strong>per_region</strong> : boolean, optional</p>
<blockquote>
<div><p>If true, reports the accounts per region</p>
</div></blockquote>
<p><strong>per_capita</strong> : boolean, optional</p>
<blockquote>
<div><p>If true, reports the accounts per capita
If per_capita and per_region are False, nothing will be done</p>
</div></blockquote>
<p><strong>pic_size</strong> : int, optional</p>
<blockquote>
<div><p>size for the figures in px, 1000 by default</p>
</div></blockquote>
<p><strong>format</strong> : string, optional</p>
<blockquote>
<div><p>file format of the report:
&#8216;rst&#8217;(default), &#8216;html&#8217;, &#8216;latex&#8217;, ...  
except for rst all depend on the module docutils (all writer_name 
from docutils can be used as format)</p>
</div></blockquote>
<p><strong>ffname</strong> : string, optional</p>
<blockquote>
<div><p>root file name (without extension, per_capita or per_region will be
attached) and folder names If None gets passed (default), self.name
with be modified to get a valid name for the operation system
without blanks</p>
</div></blockquote>
<p><strong>**kwargs</strong> : key word arguments, optional</p>
<blockquote class="last">
<div><p>This will be passed directly to the pd.DataFrame.plot method
(through the self.plot_account method)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymrio.IOSystem">
<em class="property">class </em><tt class="descclassname">pymrio.</tt><tt class="descname">IOSystem</tt><big>(</big><em>Z=None</em>, <em>Y=None</em>, <em>A=None</em>, <em>x=None</em>, <em>L=None</em>, <em>unit=None</em>, <em>population=None</em>, <em>iosystem=None</em>, <em>version=None</em>, <em>year=None</em>, <em>price=None</em>, <em>name='IO'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing a whole EE MRIO System</p>
<p>The class collects pandas dataframes for a whole EE MRIO system. The
attributes for the trade matrices (Z, L, A, x, Y) can be set directly,
extensions are given as dictionaries containing F, FY, D, m, D_fp, D_terr,
D_imp, D_exp</p>
<p class="rubric">Notes</p>
<p>The attributes and extension dictionary entries are pandas.DataFrame with
an MultiIndex.  This index must have the specified level names.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Z</td>
<td>(pandas.DataFrame) Symetric input output table (flows) with country and sectors as MultiIndex with names &#8216;region&#8217; and &#8216;sector&#8217; for columns and index</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>(pandas.DataFrame) final demand with MultiIndex with index.names = ([&#8216;region&#8217;, &#8216;sector&#8217;]) and column.names = ([&#8216;region&#8217;, &#8216;category&#8217;])</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>(pandas.DataFrame) coefficient input output table, MultiTndex as Z</td>
</tr>
<tr class="row-even"><td>L</td>
<td>(pandas.DataFrame) Leontief, MultiTndex as Z</td>
</tr>
<tr class="row-odd"><td>unit</td>
<td>(pandas.DataFrame) Unit for each row of Z</td>
</tr>
<tr class="row-even"><td>iosystem</td>
<td>(string) Note for the IOSystem, recommended to be &#8216;pxp&#8217; or &#8216;ixi&#8217; for product by product or industry by industry. However, this can be any string and can have more information if needed (eg for different technoloy assumptions) The string will be passed to the IOSystem</td>
</tr>
<tr class="row-odd"><td>version</td>
<td>(string) This can be used as a version tracking system.</td>
</tr>
<tr class="row-even"><td>year</td>
<td>(string or int) Baseyear of the IOSystem</td>
</tr>
<tr class="row-odd"><td>price</td>
<td>(string) Price system of the IO (current or constant prices)</td>
</tr>
<tr class="row-even"><td>name</td>
<td>(string, optional) Name of the IOSystem, default is &#8216;IO&#8217;</td>
</tr>
<tr class="row-odd"><td><a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs</td>
<td>(dictonary) Extensions are given as dictionaries and will be passed to the Extension class.  The dict must contain a key with a value for &#8216;name&#8217;, this can be the same as the name of the dict.  For the further keys see class Extension</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="pymrio.IOSystem.aggregate">
<tt class="descname">aggregate</tt><big>(</big><em>region_agg=None</em>, <em>sector_agg=None</em>, <em>region_dict=None</em>, <em>sector_dict=None</em>, <em>recalc=False</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregates the IO system</p>
<p>This removes all data which can&#8217;t be aggregated (coefficients)
these must be recalculated afterwards</p>
<p>Aggregation can be given as vector (use pymrio.build_agg_vec) or
aggregation matrix. In the case of a vector this must be of length
self.get_regions() / self.get_sectors() respectively with the new
position as integer or a string of the new name. In the case of
strings the final output order can be specified in region_dict and
sector_dict in the format {str1 = int_pos, str2 = int_pos, ...}.</p>
<p>If the sector / region concordance is given as matrix or numerical
vector, generic names will be used for the new sectors/regions. One
can define specific names by defining the aggregation as string
vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>region_agg</strong> : list or array, optional</p>
<blockquote>
<div><p>The aggregation vector or matrix for the regions (np.ndarray or
list)</p>
</div></blockquote>
<p><strong>sector_agg</strong> : list or arrays, optional</p>
<blockquote>
<div><p>The aggregation vector or matrix for the sectors (np.ndarray or
list)</p>
</div></blockquote>
<p><strong>region_dict</strong> : dict, optional</p>
<blockquote>
<div><p>Information to reorder the aggregated regions</p>
</div></blockquote>
<p><strong>secotor_dict</strong> : dict, optional</p>
<blockquote>
<div><p>Information to reorder the aggregated sectors</p>
</div></blockquote>
<p><strong>recalc</strong> : boolean, optional</p>
<blockquote>
<div><p>Recalc IOSystem and accounts after aggregation, default: False</p>
</div></blockquote>
<p><strong>inplace</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, aggregates the IOSystem in place, otherwise return a
new IOSystem (default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">Aggregated IOSystem (if inplace is False)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.calc_all">
<tt class="descname">calc_all</tt><big>(</big><em>recalc=False</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.calc_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates missing parts of the IOSystem and all extensions.</p>
<p>This method call calc_system and calc_extensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>recalc</strong> : boolean, optional</p>
<blockquote class="last">
<div><p>If true, recalc all attributes (reset the
IOSystem and all Extensions)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.calc_extensions">
<tt class="descname">calc_extensions</tt><big>(</big><em>extensions=None</em>, <em>Y_agg=None</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.calc_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the extension and their accounts</p>
<p>For the calculation, y is aggregated across specified y categories
The method calls .calc_system of each extension (or these given in the
extensions parameter)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>extensions</strong> : list of strings, optional</p>
<blockquote>
<div><p>A list of key names of extensions which shall be calculated. 
Default: all dictionaries of IOSystem are assumed to be extensions</p>
</div></blockquote>
<p><strong>Y_agg</strong> : pandas.DataFrame or np.array, optional</p>
<blockquote class="last">
<div><p>The final demand aggregated (one category per country)
Default: y is aggregated over all categories</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.calc_system">
<tt class="descname">calc_system</tt><big>(</big><big>)</big><a class="headerlink" href="#pymrio.IOSystem.calc_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the missing part of the core IOSystem</p>
<p>The method checks Z, x, A, L and calculates all which are None</p>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.get_extensions">
<tt class="descname">get_extensions</tt><big>(</big><em>data=False</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.get_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generator for the extension in the IOSystem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, returns a generator which yields the dicts of the
extensions.  
If False, returns a generator which yields the names of
the extensions (default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">generator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.remove_extension">
<tt class="descname">remove_extension</tt><big>(</big><em>ext=None</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.remove_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove extension from IOSystem</p>
<p>For single Extensions the same can be achieved with del
IOSystem_name.Extension_name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ext</strong> : string or list, optional</p>
<blockquote class="last">
<div><p>The extension to remove, this can be given as the name of the
instance or of Extension.name (the latter will be checked if no
instance was found)
If ext is None (default) all Extensions will be removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.report_accounts">
<tt class="descname">report_accounts</tt><big>(</big><em>path</em>, <em>per_region=True</em>, <em>per_capita=False</em>, <em>pic_size=1000</em>, <em>format='rst'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.report_accounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a report to the given path for all extension</p>
<p>This method calls .report_accounts for all extensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote>
<div><p>Root path for the report</p>
</div></blockquote>
<p><strong>per_region</strong> : boolean, optional</p>
<blockquote>
<div><p>If true, reports the accounts per region</p>
</div></blockquote>
<p><strong>per_capita</strong> : boolean, optional</p>
<blockquote>
<div><p>If true, reports the accounts per capita
If per_capita and per_region are False, nothing will be done</p>
</div></blockquote>
<p><strong>pic_size</strong> : int, optional</p>
<blockquote>
<div><p>size for the figures in px, 1000 by default</p>
</div></blockquote>
<p><strong>format</strong> : string, optional</p>
<blockquote>
<div><p>file format of the report:
&#8216;rst&#8217;(default), &#8216;html&#8217;, &#8216;latex&#8217;, ...  
except for rst all depend on the module docutils (all writer_name
from docutils can be used as format)</p>
</div></blockquote>
<p><strong>ffname</strong> : string, optional</p>
<blockquote>
<div><p>root file name (without extension, per_capita or per_region will be
attached) and folder names If None gets passed (default), self.name
with be modified to get a valid name for the operation system
without blanks</p>
</div></blockquote>
<p><strong>**kwargs</strong> : key word arguments, optional</p>
<blockquote class="last">
<div><p>This will be passed directly to the pd.DataFrame.plot method
(through the self.plot_account method)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.report_per_capita">
<tt class="descname">report_per_capita</tt><big>(</big><em>path</em>, <em>extensions=None</em>, <em>pic_size=1000</em>, <em>format='rst'</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.report_per_capita" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a report to the given path for all country specific accounts</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote>
<div><p>Root path for the per capita report</p>
</div></blockquote>
<p><strong>extensions</strong> : list of strings, optional</p>
<blockquote>
<div><p>A list of key names of extensions which shall be calculated. 
Default: all dictionaries of IOSystem are assumed to be extensions</p>
<blockquote>
<div><p>if given, accounts per person are also included in the report</p>
</div></blockquote>
</div></blockquote>
<p><strong>pic_size</strong> : int</p>
<blockquote>
<div><p>size for the figures in px, 1000 by default</p>
</div></blockquote>
<p><strong>format</strong> : string</p>
<blockquote class="last">
<div><p>file format of the report:
&#8216;rst&#8217;(default), &#8216;html&#8217;, &#8216;latex&#8217;, ...  
except for rst all depend on the module docutils (all writer_name from docutils can be used as format)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymrio.IOSystem.save_all">
<tt class="descname">save_all</tt><big>(</big><em>path</em>, <em>table_format='txt'</em>, <em>sep='t'</em>, <em>table_ext=None</em>, <em>float_format='%.12g'</em><big>)</big><a class="headerlink" href="#pymrio.IOSystem.save_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the system and all extensions</p>
<p>Extensions are saved in separate folders (names based on extension)</p>
<p>Parameters are passed to the .save methods of the IOSystem and
Extensions</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymrio.build_agg_vec">
<tt class="descclassname">pymrio.</tt><tt class="descname">build_agg_vec</tt><big>(</big><em>agg_vec</em>, <em>**source</em><big>)</big><a class="headerlink" href="#pymrio.build_agg_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds an combined aggregation vector based on various classifications</p>
<p>This function build an aggregation vector based on the order in agg_vec.
The naming and actual mapping is given in <a href="#id3"><span class="problematic" id="id4">**</span></a>source, either explicitly or by
pointing to a folder with the mapping.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">build_agg_vec</span><span class="p">([</span><span class="s">&#39;EU&#39;</span><span class="p">,</span> <span class="s">&#39;OECD&#39;</span><span class="p">],</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span><span class="p">)</span>
<span class="go">[&#39;EU&#39;, &#39;EU&#39;, &#39;EU&#39;, &#39;OECD&#39;, &#39;REST&#39;, &#39;REST&#39;]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">build_agg_vec</span><span class="p">([</span><span class="s">&#39;OECD&#39;</span><span class="p">,</span> <span class="s">&#39;EU&#39;</span><span class="p">],</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span><span class="p">,</span> <span class="n">miss</span><span class="o">=</span><span class="s">&#39;RoW&#39;</span><span class="p">)</span>
<span class="go">[&#39;OECD&#39;, &#39;EU&#39;, &#39;OECD&#39;, &#39;OECD&#39;, &#39;RoW&#39;, &#39;RoW&#39;]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">build_agg_vec</span><span class="p">([</span><span class="s">&#39;EU&#39;</span><span class="p">,</span> <span class="s">&#39;orig_regions&#39;</span><span class="p">],</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span><span class="p">)</span>
<span class="go">[&#39;EU&#39;, &#39;EU&#39;, &#39;EU&#39;, &#39;reg4&#39;, &#39;reg5&#39;, &#39;reg6&#39;]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">build_agg_vec</span><span class="p">([</span><span class="s">&#39;supreg1&#39;</span><span class="p">,</span> <span class="s">&#39;other&#39;</span><span class="p">],</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span><span class="p">,</span> 
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;other1&#39;</span><span class="p">,</span> <span class="s">&#39;other1&#39;</span><span class="p">,</span> <span class="s">&#39;other2&#39;</span><span class="p">,</span> <span class="s">&#39;other2&#39;</span><span class="p">])</span>
<span class="go">[&#39;supreg1&#39;, &#39;supreg1&#39;, &#39;other1&#39;, &#39;other1&#39;, &#39;other2&#39;, &#39;other2&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>agg_vec</strong> : list</p>
<blockquote>
<div><p>A list of sector or regions to which the IOSystem shall be aggregated.     
The order in agg_vec is important: 
If a string was assigned to one specific entry it will not be
overwritten if it is given in the next vector, e.g.  [&#8216;EU&#8217;, &#8216;OECD&#8217;]
would aggregate first into EU and the remaining one into OECD, whereas
[&#8216;OECD&#8217;, &#8216;EU&#8217;] would first aggregate all countries into OECD and than
the remaining countries into EU.</p>
</div></blockquote>
<p><strong>**source</strong> : list or string</p>
<blockquote>
<div><p>Definition of the vectors in agg_vec.  The input vectors (either in the
file or given as list for the entries in agg_vec) must be as long as
the desired output with a string for every position which should be
aggregated and None for position which should not be used.</p>
<p>Special keywords:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">Path to a folder with concordance matrices.     </span></dt>
<dd><p class="first">The files in the folder can have any extension but must be
in text format (tab separated) with one entry per row.
The last column in the file will be taken as aggregation
vectors (other columns can be used for documentation).
Values must be given for every entry in the original
classification (string None for all values not used) If
the same entry is given in <a href="#id5"><span class="problematic" id="id6">**</span></a>source and as text file in
path than the one in <a href="#id7"><span class="problematic" id="id8">**</span></a>source will be used.</p>
<p>Two special path entries are available so far:</p>
<ul class="simple">
<li>&#8216;exio2&#8217;
Concordance matrices for EXIOBASE 2.0</li>
<li>&#8216;test&#8217;
Concordance matrices for the test IO system</li>
</ul>
<p class="last">If a entry is not found in <a href="#id9"><span class="problematic" id="id10">**</span></a>source and no path is given
the current directory will be searched for the definition.</p>
</dd>
</dl>
</li>
<li><p class="first">miss : Entry to use for missing values, default: &#8216;REST&#8217;</p>
</li>
</ul>
</div></blockquote>
</div></blockquote>
<p class="last"><strong>Returns: list</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_A">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_A</tt><big>(</big><em>Z</em>, <em>x</em><big>)</big><a class="headerlink" href="#pymrio.calc_A" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the A matrix (coefficients) from Z and x</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Symmetric input output table (flows)</p>
</div></blockquote>
<p><strong>x</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Industry output column vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Symmetric input output table (coefficients) A
The type is determined by the type of Z. 
If DataFrame index/columns as Z</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_L">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_L</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#pymrio.calc_L" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Leontief L from A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>A</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Symmetric input output table (coefficients)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Leontief input output table L
The type is determined by the type of A. 
If DataFrame index/columns as A</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_M">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_M</tt><big>(</big><em>S</em>, <em>L</em><big>)</big><a class="headerlink" href="#pymrio.calc_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate multipliers of the extensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>L</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Leontief input output table L</p>
</div></blockquote>
<p><strong>S</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Direct impact coefficients</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Multipliers M
The type is determined by the type of D. 
If DataFrame index/columns as D</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_S">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_S</tt><big>(</big><em>F</em>, <em>x</em><big>)</big><a class="headerlink" href="#pymrio.calc_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate extensions/factor inputs coefficients</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>F</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Total direct impacts</p>
</div></blockquote>
<p><strong>x</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Industry output column vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Direct impact coefficients S
The type is determined by the type of F. 
If DataFrame index/columns as F</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_Z">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_Z</tt><big>(</big><em>A</em>, <em>x</em><big>)</big><a class="headerlink" href="#pymrio.calc_Z" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the Z matrix (flows) from A and x</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>A</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Symmetric input output table (coefficients)</p>
</div></blockquote>
<p><strong>x</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Industry output column vector</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Symmetric input output table (flows) Z
The type is determined by the type of A. 
If DataFrame index/columns as A</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_accounts">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_accounts</tt><big>(</big><em>S</em>, <em>L</em>, <em>Y</em>, <em>nr_countries</em>, <em>nr_sectors</em><big>)</big><a class="headerlink" href="#pymrio.calc_accounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sector specific footprints, terr, imp and exp accounts</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>L</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Leontief input output table L</p>
</div></blockquote>
<p><strong>S</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Direct impact coefficients</p>
</div></blockquote>
<p><strong>Y</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Final demand: aggregated across categories or just one category, one
column per country</p>
</div></blockquote>
<p><strong>nr_countries</strong> : int</p>
<blockquote>
<div><p>Number of countries in the MRIO</p>
</div></blockquote>
<p><strong>nr_sectors</strong> : int</p>
<blockquote>
<div><p>Number of sectors in the MRIO</p>
</div></blockquote>
<p><strong>The total industry output x for the calculation</strong></p>
<p><strong>is recalculated from L and y</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">Tuple</p>
<blockquote class="last">
<div><p>(D_fp, D_terr, D_imp, D_exp)
Format: D_row x L_col (=nr_countries*nr_sectors)
D_fp        Footprint per sector and country
D_terr      Total factur use per sector and country
D_imp       Total global factor use to satisfy total final demand in</p>
<blockquote>
<div><p>the country per sector</p>
</div></blockquote>
<dl class="docutils">
<dt>D_exp       Total factor use in one country to satisfy final demand in</dt>
<dd><p class="first last">all other countries (per sector)</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_e">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_e</tt><big>(</big><em>M</em>, <em>Y</em><big>)</big><a class="headerlink" href="#pymrio.calc_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate total impacts (footprints of consumption Y)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>M</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Multipliers</p>
</div></blockquote>
<p><strong>Y</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Final consumption</p>
</div></blockquote>
<p><strong>TODO - this must be completely redone (D, check for dataframe, ...)</strong></p>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>pandas.DataFrame or numpy.array</strong></p>
<blockquote>
<div><p>Multipliers m
The type is determined by the type of D. 
If DataFrame index/columns as D</p>
</div></blockquote>
<p class="last"><strong>The calcubased on multipliers M and finald demand Y</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.calc_x">
<tt class="descclassname">pymrio.</tt><tt class="descname">calc_x</tt><big>(</big><em>Z</em>, <em>Y</em><big>)</big><a class="headerlink" href="#pymrio.calc_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the industry output x from the Z and Y matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>Symmetric input output table (flows)</p>
</div></blockquote>
<p><strong>Y</strong> : pandas.DataFrame or numpy.array</p>
<blockquote>
<div><p>final demand with categories (1.order) for each country (2.order)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">pandas.DataFrame or numpy.array</p>
<blockquote class="last">
<div><p>Industry output x as column vector
The type is determined by the type of Z. If DataFrame index as Z</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.concate_extension">
<tt class="descclassname">pymrio.</tt><tt class="descname">concate_extension</tt><big>(</big><em>name</em>, <em>*extensions</em><big>)</big><a class="headerlink" href="#pymrio.concate_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate extensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>extensions</strong> : Extensions</p>
<blockquote>
<div><p>The Extensions to concatenate as multiple parameters</p>
</div></blockquote>
<p><strong>name</strong> : string</p>
<blockquote>
<div><p>Name of the new extension</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last">Concatenated extension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.load">
<tt class="descclassname">pymrio.</tt><tt class="descname">load</tt><big>(</big><em>path</em>, <em>recursive=False</em>, <em>ini=None</em>, <em>subini={}</em><big>)</big><a class="headerlink" href="#pymrio.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a IOSystem or Extension from a ini files</p>
<p>This function can be used to load a IOSystem or Extension specified in a
ini file. DataFrames (tables) are loaded from text or binary pickle files.
For the latter, the extension .pkl or .pickle is assumed, in all other case
the tables are assumed to be in txt format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote>
<div><p>path or ini file name for the data to load</p>
</div></blockquote>
<p><strong>recursive</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, load also the data in the subfolders and add them as
extensions to the IOSystem (in that case path must point to the root).
Only first order subfolders are considered (no subfolders in
subfolders) and if a folder does not contain a ini file it&#8217;s skipped.
Use the subini parameter in case of multiple ini files in a subfolder.
Attribute name of the extension in the IOSystem are based on the
subfolder name.  Default is False</p>
</div></blockquote>
<p><strong>ini</strong> : string, optional</p>
<blockquote>
<div><p>If there are several ini files in the root folder, take this one for
loading the data If None (default) take the ini found in the folder,
error if several are found</p>
</div></blockquote>
<p><strong>subini: dict, optional</strong></p>
<blockquote class="last">
<div><p>If there are multiple ini in the subfolder, use the ini given in the
dict.  Format: &#8216;subfoldername&#8217;:&#8217;ininame&#8217; If a key for a subfolder is
not found or None (default), the ini found in the folder will be taken,
error if several are found</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.load_all">
<tt class="descclassname">pymrio.</tt><tt class="descname">load_all</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pymrio.load_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the whole IOSystem with Extensions given in path</p>
<p>This just calls pymrio.load with recursive = True. If several ini files are
present, use the low level load function directly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote class="last">
<div><p>path or ini file name for the data to load</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.load_test">
<tt class="descclassname">pymrio.</tt><tt class="descname">load_test</tt><big>(</big><big>)</big><a class="headerlink" href="#pymrio.load_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a small test MRIO</p>
<p>This function can be used as an example of how to parse an IOSystem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body">IOSystem</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymrio.parse_exiobase22">
<tt class="descclassname">pymrio.</tt><tt class="descname">parse_exiobase22</tt><big>(</big><em>path</em>, <em>charact=None</em>, <em>iosystem=None</em>, <em>version='exiobase 2.2'</em>, <em>popvector='exio2'</em><big>)</big><a class="headerlink" href="#pymrio.parse_exiobase22" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the exiobase 2.2 source files for the IOSystem</p>
<p>The function parse product by product and industry by industry source file
with flow matrices (Z)</p>
<p>The A matrix can than be calculated within the IOSystem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>path</strong> : string</p>
<blockquote>
<div><p>Path to the EXIOBASE source files</p>
</div></blockquote>
<p><strong>charact</strong> : string, optional</p>
<blockquote>
<div><p>Filename with path to the characterisation matrices for the extensions
(xls).  This is provided together with the EXIOBASE system and given as
a xls file The four sheets  Q_factorinputs, Q_emission, Q_materials and
Q_resources are read and used to generate one new extensions with the
impacts</p>
</div></blockquote>
<p><strong>iosystem</strong> : string, optional</p>
<blockquote>
<div><p>Note for the IOSystem, recommended to be &#8216;pxp&#8217; or &#8216;ixi&#8217; for
product by product or industry by industry.
However, this can be any string and can have more information if needed
(eg for different technology assumptions)
The string will be passed to the IOSystem</p>
</div></blockquote>
<p><strong>version</strong> : string, optional</p>
<blockquote>
<div><p>This can be used as a version tracking system. Default: exiobase 2.2</p>
</div></blockquote>
<p><strong>popvector</strong> : string or pd.DataFrame, optional</p>
<blockquote>
<div><p>The population vector for the countries.  This can be given as
pd.DataFrame(index = population, columns = countrynames) or, (default)
will be taken from the pymrio module If popvector = None no population
data will be passed to the IOSystem</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">IOSystem</p>
<blockquote>
<div><p>A IOSystem with the parsed exiobase 2 data</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>EXIOError</strong></p>
<blockquote class="last">
<div><p>If the exiobase source files are not complete in the given path</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API Reference</a><ul>
<li><a class="reference internal" href="#function-and-classes-for-symmetric-mrio-systems">Function and classes for (symmetric) MRIO systems</a><ul>
<li><a class="reference internal" href="#data-storage">Data storage</a></li>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#misc">Misc</a></li>
<li><a class="reference internal" href="#open-points">Open points</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/. api_references.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pymrio 1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Konstantin Stadler.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>